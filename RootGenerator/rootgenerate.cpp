/*
    This software is Copyright by the Board of Trustees of Michigan
    State University (c) Copyright 2017.

    You may use this software under the terms of the GNU public license
    (GPL).  The terms of this license are described at:

     http://www.gnu.org/licenses/gpl.txt

     Authors:
             Ron Fox
             Giordano Cerriza
	     NSCL
	     Michigan State University
	     East Lansing, MI 48824-1321
*/

/** @file:  rootgenerate.cpp
 *  @brief: Code generator for the CERN Root.
 */

/**
 * This program generates code to support environment neutral unpacking
 * of event data.  The intermediate representation of type and instance
 * definitions generated by the parser for the data definition language
 * is taken as input on stdin (so we can be pipelined).  A .h and
 * .cpp file are generated.
 *
 * Usage:
 *      rootgenerate basename
 *
 * Which generates basename.h, basename.cpp, and basename-linkdef.h
 * basename.h, basename.cpp are sufficient for the unpacking code
 * basename-linkdef.h provides a file that can be used to generate a
 * root dictionary for the classes/structs we generate.
 */

#include <iostream>
#include <instance.h>
#include <definedtypes.h>
#include <fstream>
#include <stdlib.h>
#include <libgen.h>
#include <string.h>

const char* programVersionString("rootgenerate version 1.0 (c) NSCL/FRIB");

/**
 * usage
 *    Outputs an error message and program usage text to the desired
 *    stream.
 *
 * @param f - the stream to which output is directed.
 * @param msg - the message that precedes the usage text.
 */
static void
usage(std::ostream& f, const char * msg)
{
    f << msg << std::endl;
    f << "Usage\n";
    f << "   rootgenerate basename\n";
    f << "Where:\n";
    f << "   basename is the base name for the generated files.  The files\n";
    f << "            created are basename.h, basename.cpp and basename-linkdef.h\n";
    f << "The program expects the intermediate representation to be on stdin\n";
    
    exit(EXIT_FAILURE);
}


/**
 * generateHeader
 *    Generate the header file.
 *
 *  @param fname - name of the output file.
 *  @param nsname - name of the namespace all the decls go into.
 *  @param types  - list of data types.
 *  @param instances - list of top level instances.
 */
static void
generateHeader(
    const std::string& fname, const std::string& nsname,
    const std::list<TypeDefinition>& types, const std::list<Instance>& instances
)
{
    std::ofstream f(fname.c_str());
    // commentHeader(fname, "Defines types, instances and API");
    
    f << "#ifndef " << nsname << "_h" <<  std::endl;
    f << "#define " << nsname << "_h" <<  std::endl;
    f << "#include <TObject.h>\n";
    
    f << "#endif\n";
    f.close();
}

/**
 * main
 *   entry point
 */
int main (int argc, char** argv)
{
    if (argc != 2) {
        usage(std::cerr, "Incorrect number of command line parameters");
    }
    // Deserialize the intermediate representation:
    
    std::list<TypeDefinition> types;
    deserializeTypes(std::cin, types);
    
    std::list<Instance> instances;
    deserializeInstances(std::cin, instances);
    
    // From the base name generate the names of the namespace, header, source
    // and linkdef file.  Note that for the namespace, we use basename to
    // remove any path information from basename as the user could do:
    //
    // rootgenerate ~/rootstuff/base
    //
    // which, by the time we're done gives us a namespace of base.
    
    
    std::string base   = argv[1];
    std::string headerName = base + ".h";
    std::string cppName    = base + ".cpp";
    std::string linkdefName = base + "-linkdef.h";
    
    char cstrFilename[base.size() +1];  // all because basename(3) an
    strcpy(cstrFilename, base.c_str()); // modify its parameter.
    
    std::string nsname  = basename(cstrFilename);
    
    
    //  Here we go:
    
    generateHeader(headerName, nsname, types, instances);
    
}

void yyerror(const char* msg)
{
    usage(std::cerr, msg);
}